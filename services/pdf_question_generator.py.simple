"""
PDF問題生成サービス（シンプル版）
PDFテキストから複数選択問題を生成する
"""

from typing import List, Dict, Optional
import json
from services.enhanced_openai_service import EnhancedOpenAIService


class PDFQuestionGenerator:
    """PDF問題生成クラス（シンプル版）"""
    
    def __init__(self, session, model_name="gpt-4o-mini"):
        self.session = session
        self.openai_service = EnhancedOpenAIService(model_name=model_name)
    
    def generate_questions_from_pdf(
        self,
        text: str,
        num_questions: int = 5,
        difficulty: str = "medium",
        category: str = "PDF教材",
        model: str = "gpt-4o-mini",
        include_explanation: bool = True,
        progress_callback=None,
        enable_duplicate_check: bool = True,
        similarity_threshold: float = 0.7,
        max_retry_attempts: int = 3,
        allow_multiple_correct: bool = False
    ) -> List[int]:
        """PDFテキストから問題を生成"""
        
        if progress_callback:
            progress_callback("PDFテキストから問題を生成中...", 0.5)
        
        # シンプル版では全テキストを一度に処理
        try:
            question_ids = self._generate_questions(
                text, num_questions, difficulty, category, model, 
                include_explanation, enable_duplicate_check, 
                similarity_threshold, max_retry_attempts, allow_multiple_correct
            )
            
            if progress_callback:
                progress_callback("問題生成完了！", 1.0)
            
            return question_ids
            
        except Exception as e:
            print(f"問題生成でエラー: {e}")
            if progress_callback:
                progress_callback(f"エラーが発生しました: {e}", 1.0)
            return []
    
    def _generate_questions(
        self,
        text: str,
        num_questions: int,
        difficulty: str,
        category: str,
        model: str,
        include_explanation: bool,
        enable_duplicate_check: bool,
        similarity_threshold: float,
        max_retry_attempts: int,
        allow_multiple_correct: bool
    ) -> List[int]:
        """テキストから問題を生成"""
        
        # 指定されたモデルでOpenAIサービスを初期化
        openai_service = EnhancedOpenAIService(model_name=model)
        
        # 解説を含めるかどうかでプロンプトを調整
        explanation_instruction = "詳細な解説を含める" if include_explanation else "解説は不要"
        explanation_field = '"explanation": "正解の理由と解説"' if include_explanation else '"explanation": ""'
        
        # 複数正解に関する指示を調整
        multiple_correct_instruction = "問題によっては複数の正解が可能です" if allow_multiple_correct else "必ず1つの正解と3つの不正解を含む"
        
        # テキストを制限
        max_text_length = 2000
        if len(text) > max_text_length:
            text = text[:max_text_length] + "...[テキスト省略]"
        
        prompt = f"""
以下のテキストを基に、{num_questions}個の4択問題を作成してください。

【テキスト内容】
{text}

【要求事項】
- 難易度: {difficulty}
- カテゴリ: {category}
- 各問題は4つの選択肢を持つ
- {multiple_correct_instruction}
- 実際のテキスト内容に基づいた問題を作成
- 問題は理解度を測るものにする
- {explanation_instruction}

【出力形式】（JSON形式で回答）
{{
    "questions": [
        {{
            "title": "問題のタイトル",
            "content": "問題文",
            "choices": [
                {{"text": "選択肢A", "is_correct": false}},
                {{"text": "選択肢B", "is_correct": true}},
                {{"text": "選択肢C", "is_correct": false}},
                {{"text": "選択肢D", "is_correct": false}}
            ],
            {explanation_field}
        }}
    ]
}}

JSONのみを出力し、他の文字は含めないでください。
"""

        try:
            # OpenAI APIで問題生成
            response = openai_service.generate_completion(
                prompt=prompt,
                max_tokens=2000,
                temperature=0.7
            )
            
            # JSONパース
            questions_data = json.loads(response)
            
            # 問題をDBに保存
            question_ids = []
            for q_data in questions_data.get('questions', []):
                question_id = self._save_question_to_db(
                    q_data, category, difficulty,
                    enable_duplicate_check, similarity_threshold, max_retry_attempts
                )
                if question_id:
                    question_ids.append(question_id)
            
            return question_ids
            
        except json.JSONDecodeError as e:
            print(f"JSON解析エラー: {e}")
            return []
        except Exception as e:
            print(f"問題生成エラー: {e}")
            return []

    def _save_question_to_db(
        self,
        question_data: Dict,
        category: str,
        difficulty: str,
        enable_duplicate_check: bool,
        similarity_threshold: float,
        max_retry_attempts: int
    ) -> Optional[int]:
        """問題をデータベースに保存"""
        
        try:
            from database.operations import QuestionService, ChoiceService
            
            question_service = QuestionService(self.session)
            choice_service = ChoiceService(self.session)
            
            # 重複チェック
            if enable_duplicate_check:
                existing = question_service.find_similar_questions(
                    question_data['content'], 
                    threshold=similarity_threshold
                )
                if existing:
                    print(f"類似問題が既に存在するためスキップ: {question_data.get('title', '無題')}")
                    return None
            
            # 問題を保存
            question_id = question_service.create_question(
                title=question_data.get('title', '無題'),
                content=question_data['content'],
                category=category,
                difficulty=difficulty,
                explanation=question_data.get('explanation', '')
            )
            
            if not question_id:
                return None
            
            # 選択肢を保存
            for order, choice in enumerate(question_data['choices']):
                choice_service.create_choice(
                    question_id=question_id,
                    content=choice['text'],
                    is_correct=choice['is_correct'],
                    order_num=order + 1
                )
            
            return question_id
            
        except Exception as e:
            print(f"DB保存エラー: {e}")
            return None
